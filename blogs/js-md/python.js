var defaultItem = 'python-1-sqlalchemy'
var jsObj ={
	'python-1-sqlalchemy':{
		'title':'SQLAlchemy——Python SQL toolkit and ORM',
		'content':"![这里写图片描述](http://img.blog.csdn.net/20180206184548334?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG9ja2V5MjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\nORM：Object-Relational Mapping，把关系数据库的表结构映射到对象上。\n在Python中，最有名的ORM框架是SQLAlchemy。\n\n**本文以操作MySQL数据库为例**\n\n### 1. 安装SQLAlchemy\n\n\tpip install SQLAlchemy\n\t\nmysql windows安装\nhttps://dev.mysql.com/downloads/installer/\n\n### 2. 创建数据库引擎\n\nThe Engine is the starting point for any SQLAlchemy application. It’s “home base” for the actual database and its DBAPI, delivered to the SQLAlchemy application through a connection pool and a Dialect, which describes how to talk to a specific kind of database/DBAPI combination.\n\nThe general structure can be illustrated as follows:\n![这里写图片描述](http://img.blog.csdn.net/20180206184533468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG9ja2V5MjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\nWhere above, an Engine references both a Dialect and a Pool, which together interpret the DBAPI’s module functions as well as the behavior of the database.\n\nCreating an engine is just a matter of issuing a single call, create_engine():\n\n**from sqlalchemy import create_engine**\n**engine = create_engine('postgresql://scott:tiger@localhost:5432/mydatabase')**\n\nThe above engine creates a Dialect object tailored towards PostgreSQL, as well as a Pool object which will establish a DBAPI connection at localhost:5432 when a connection request is first received. Note that the Engine and its underlying Pool do not establish the first actual DBAPI connection until the Engine.connect() method is called, or an operation which is dependent on this method such as Engine.execute() is invoked. In this way, Engine and Pool can be said to have a lazy initialization behavior.\n\nThe Engine, once created, can either be used directly to interact with the database, or can be passed to a Session object to work with the ORM. This section covers the details of configuring an Engine. The next section, Working with Engines and Connections, will detail the usage API of the Engine and similar, typically for non-ORM applications.\n\nDatabase Urls\nThe create_engine() function produces an Engine object based on a URL. These URLs follow RFC-1738, and usually can include username, password, hostname, database name as well as optional keyword arguments for additional configuration. In some cases a file path is accepted, and in others a “data source name” replaces the “host” and “database” portions. \n\n**The typical form of a database URL is:**\n\n\tdialect+driver://username:password@host:port/database\nDialect names include the identifying name of the SQLAlchemy dialect, a name such as sqlite, mysql, postgresql, oracle, or mssql. The drivername is the name of the DBAPI to be used to connect to the database using all lowercase letters. If not specified, a “default” DBAPI will be imported if available - this default is typically the most widely known driver available for that backend.\n\n**对于各种引擎创建方式：**\n数据库+数据库驱动，只要安装了相应的数据库和驱动都能使用。\n\n\t1、create_engine('mysql+mysqlconnector://root:password@localhost:3306/test')\n\t这个mysqlconnector是MySQL自带的数据库驱动程序\n\t\n\t2、create_engine('mysql+mysqldb://root:password@localhost:3306/test')\n\t使用mysqldb驱动连接数据库\n\t\n\t3、create_engine('mysql://root:password@localhost:3306/test')\n\t这个没有驱动器的情况下\n\n### 3. 数据库操作\n\n#### 3.1 使用传统的connection的方式连接和操作数据库\nconnection事务：使用事务可以进行批量提交和回滚\n\n    with engine.connect() as connection:\n        trans = connection.begin()\n        try:\n            r1 = connection.execute(\"select * from user\")\n            r2 = connection.execute(\"insert into user(id,name) values( '23' ,'lockey')\")\n            trans.commit()\n        except:\n            trans.rollback()\n            raise\n####3.2 通过session对象连接并且操作数据库\n\n通过session对象，session可以记录和跟踪数据的改变，在适当的时候提交，并且支持强大的ORM的功能\n\n```\n#!/usr/bin/env python\n#coding:utf-8\n'''\nfile: sqlalchemyLearning.py\ndate: 2018/2/6 13:52\nauthor: lockey\nemail: iooiooi23@163.com\ngithub: https://github.com/LockeyCheng\ncsdn: http://blog.csdn.net/Lockey23\ndesc: \n'''\nfrom sqlalchemy import Column, String, create_engine,ForeignKey\nfrom sqlalchemy.orm import sessionmaker,relationship\nfrom sqlalchemy.ext.declarative import declarative_base\nBase = declarative_base()\n\n# 初始化数据库连接,echo为True时,会打印所有的sql语句，echo参数可省略\nengine = create_engine('mysql+mysqlconnector://lockey:lockey23@localhost:3306/test',echo=True)\n#创建表（如果表已经存在，则不会创建）\nBase.metadata.create_all(engine)\nDBSession = sessionmaker(bind=engine)\n# 创建session对象:\nsession = DBSession()\n\nclass User(Base):\n    __tablename__ = 'user'\n\n    id = Column(String(20), primary_key=True)\n    name = Column(String(20))\n    # 一对多:\n    books = relationship('Book')\n\nclass Book(Base):\n    __tablename__ = 'book'\n\n    id = Column(String(20), primary_key=True)\n    name = Column(String(20))\n    # “多”的一方的book表是通过外键关联到user表的:\n    user_id = Column(String(20), ForeignKey('user.id'))\n\ndef testfunc():\n\tuser = User(id = '13',name='lockey23')\n    book = Book(id=\"1\",name='book1')\n    user.books = [book]\n    session.add(user)\n    session.commit()\n\n\t#修改数据\n\tsession.query(User).filter(User.id == 1).update({'name': 'admin'})\n\tsession.commit()\n\n\t#删除数据\n\tsession.query(Role).filter(Role.id == 1).delete()\n\tsession.commit()\n\n\t#查询数据\n\t#1 返回结果集的第二项\n\tuser = session.query(User).get(2)\n\n\t#2 返回结果集中的第2-3项\n\tusers = session.query(User)[1:3]\n\n\t#3 查询条件\n\tuser = session.query(User).filter(User.id < 6).first()\n\n\t#4 排序\n\tusers = session.query(User).order_by(User.name)\n\n\t#5 降序（需要导入desc方法）\n\tfrom sqlalchemy import desc\n\tusers = session.query(User).order_by(desc(User.name))\n\n\t#6 只查询部分属性\n\tusers = session.query(User.name).order_by(desc(User.name))\n\tfor user in users:\n\t    print user.name\n\n\t#7 给结果集的列取别名\n\tusers = session.query(User.name.label('user_name')).all()\n\tfor user in users:\n\t    print user.user_name\n\n\t#8 去重查询（需要导入distinct方法）\n\tfrom sqlalchemy import distinct\n\tusers = session.query(distinct(User.name).label('name')).all()\n\n\t#9 统计查询\n\tuser_count = session.query(User.name).order_by(User.name).count()\n\tage_avg = session.query(func.avg(User.age)).first()\n\tage_sum = session.query(func.sum(User.age)).first()\n\n\t#10 分组查询\n\tusers = session.query(func.count(User.name).label('count'), User.age).group_by(User.age)\n\tfor user in users:\n\t    print 'age:{0}, count:{1}'.format(user.age, user.count)\n\n\t#exists查询(不存在则为~exists())\n\tfrom sqlalchemy.sql import exists\n\tsession.query(User.name).filter(~exists().where(User.name == 'lockey'))\n\n\t#除了exists，any也可以表示EXISTS\n\tsession.query(User).filter(User.name.any())\n\n\t#random\n\tfrom sqlalchemy.sql.functions import random\n\tuser = session.query(User).order_by(random()).first()\n```\n\n**多表查询**\n多表查询通常使用join进行表连接，第一个参数为表名，第二个参数为条件，例如\n\n\tusers = db.session.query(User).join(Role, Role.id == User.role_id)\n\n\tfor u in users:\n\t    print u.name\njoin为内连接，还有左连接outerjoin，用法与join类似，右连接和全外链接在1.0版本上不支持，通常来说有这两个结合查询的方法基本够用了，1.1版本貌似添加了右连接和全外连接的支持，但是目前只是预览版\n\n还可以直接查询多个表，如下\n\n\tresult = db.session.query(User, Role).filter(User.role_id = Role.id)\n\t# 这里选择的是两个表，使用元组获取数据\n\tfor u, r in result:\n\t      print u.name\n参考资料\nhttp://docs.sqlalchemy.org/en/latest/intro.html\nhttps://segmentfault.com/a/1190000006949536\nhttp://www.sqlalchemy.org/\n",
		'date':' on Feb 6, 2018'
	},
	'python-2-pillow':{
		'title':'Python图像处理库：Pillow 2.1.0',
		'content':"因为博主最近稍微研究了一下微信跳一跳辅助程序，从而认识了PIL这么个东东，然后就有了本文\n\n在微信跳一跳中Pillow主要用法：\n\n\tfrom PIL import Image\n\tim = Image.open('./autojump.png')\n\tImage.open('./autojump.png').load()\n\n\n[Pillow 2.1.0下载](https://pypi.python.org/pypi/Pillow/2.1.0#id2)\n\nPillow is the “friendly” PIL fork by Alex Clark and Contributors. PIL is the Python Imaging Library by Fredrik Lundh and Contributors.\n\n**Why a fork?**\nPIL is not setuptools compatible.\n\n**Port existing PIL-based code to Pillow**\n\nPillow is a functional drop-in replacement for the Python Imaging Library. To run your existing PIL-compatible code with Pillow, it needs to be modified to import the Imaging module from the PIL namespace instead of the global namespace. I.e. change:\n\n\timport Image\nto:\n\n\tfrom PIL import Image\n\t\n**Note**\n\nIf your code imports from _imaging, it will no longer work.\n\nThe preferred, future proof method of importing the private _imaging module is:\n\n\tfrom PIL import Image\n\t_imaging = Image.core\n\t\n### Image类\nPillow中最重要的类就是Image，该类存在于同名的模块中。可以通过以下几种方式实例化：从文件中读取图片，处理其他图片得到，或者直接创建一个图片。\n\n使用Image模块中的open函数打开一张图片：\n\n\t>>> from PIL import Image\n\t>>> img = Image.open('./autojump.png')\n\t\n\n如果打开成功，返回一个Image对象，可以通过对象属性检查文件内容\n\n\t>>> from __future__ import print_function\n\t>>> print(img.format,img.size,img.mode)\n\tPNG (1440, 2560) RGBA\n\nformat属性定义了图像的格式，如果图像不是从文件打开的，那么该属性值为None；size属性是一个tuple，表示图像的宽和高（单位为像素）；mode属性为表示图像的模式，常用的模式为：L为灰度图，RGB为真彩色，CMYK为pre-press图像。\n\n如果文件不能打开，则抛出IOError异常。\n\n当有一个Image对象时，可以用Image类的各个方法进行处理和操作图像，例如显示图片：\n\n\t>>> img.show()\n\nps：标准版本的show()方法不是很有效率，因为它先将图像保存为一个临时文件，然后使用xv进行显示。如果没有安装xv，该函数甚至不能工作。但是该方法非常便于debug和test。（windows中应该调用默认图片查看器打开）\n\n### 读写图片\nPillow库支持相当多的图片格式。直接使用Image模块中的open()函数读取图片，而不必先处理图片的格式，Pillow库自动根据文件决定格式。\n\nImage模块中的save()函数可以保存图片，除非你指定文件格式，那么文件名中的扩展名用来指定文件格式。\n\n**图片转成jpg格式**\n\n```python\nfrom __future__ import print_function\nimport os, sys\nfrom PIL import Image\n\nfor infile in sys.argv[1:]:\n    f, e = os.path.splitext(infile)\n    outfile = f + \".jpg\"\n    if infile != outfile:\n        try:\n            Image.open(infile).save(outfile)\n        except IOError:\n            print(\"cannot convert\", infile)\n```\n\nsave函数的第二个参数可以用来指定图片格式，如果文件名中没有给出一个标准的图像格式，那么第二个参数是必须的。\n\n**创建缩略图**\n\n```python\nfrom __future__ import print_function\nimport os, sys\nfrom PIL import Image\n\nsize = (128, 128)\n\nfor infile in sys.argv[1:]:\n    outfile = os.path.splitext(infile)[0] + \".thumbnail\"\n    if infile != outfile:\n        try:\n            im = Image.open(infile)\n            im.thumbnail(size)\n            im.save(outfile, \"JPEG\")\n        except IOError:\n            print(\"cannot create thumbnail for\", infile)\n```\n\n必须指出的是除非必须，Pillow不会解码或raster数据。当你打开一个文件，Pillow通过文件头确定文件格式，大小，mode等数据，余下数据直到需要时才处理。\n\n这意味着打开文件非常快，与文件大小和压缩格式无关。\n\n裁剪、粘贴、与合并图片\nImage类包含还多操作图片区域的方法。如crop()方法可以从图片中提取一个子矩形\n\n从图片中复制子图像\n\n\tbox = im.copy() #直接复制图像\n\tbox = (100, 100, 400, 400)\n\tregion = im.crop(box)\n区域由4-tuple决定，该tuple中信息为(left, upper, right, lower)。 Pillow左边系统的原点（0，0）为图片的左上角。坐标中的数字单位为像素点，所以上例中截取的图片大小为300*300像素^2。\n\n处理子图，粘贴回原图\n\n\tregion = region.transpose(Image.ROTATE_180)\n\tim.paste(region, box)\n将子图paste回原图时，子图的region必须和给定box的region吻合。该region不能超过原图。而原图和region的mode不需要匹配，Pillow会自动处理。\n\n另一个例子\n\n```\nRolling an image\n\ndef roll(image, delta):\n    \"Roll an image sideways\"\n\n    image = image.copy() #复制图像\n    xsize, ysize = image.size\n\n    delta = delta % xsize\n    if delta == 0: return image\n\n    part1 = image.crop((0, 0, delta, ysize))\n    part2 = image.crop((delta, 0, xsize, ysize))\n    image.paste(part2, (0, 0, xsize-delta, ysize))\n    image.paste(part1, (xsize-delta, 0, xsize, ysize))\n\n    return image\n```\n\n**分离和合并通道**\n\n\tr, g, b = im.split()\n\tim = Image.merge(\"RGB\", (b, g, r))\n对于单通道图片，split()返回图像本身。为了处理单通道图片，必须先将图片转成RGB。\n\n**几何变换**\n\nImage类有resize()、rotate()和transpose()、transform()方法进行几何变换。\n\n**简单几何变换**\n\n\tout = im.resize((128, 128))\n\tout = im.rotate(45) # 顺时针角度表示\n**置换图像**\n\n\tout = im.transpose(Image.FLIP_LEFT_RIGHT)\n\tout = im.transpose(Image.FLIP_TOP_BOTTOM)\n\tout = im.transpose(Image.ROTATE_90)\n\tout = im.transpose(Image.ROTATE_180)\n\tout = im.transpose(Image.ROTATE_270)\n\ttranspose()和象的rotate()没有性能差别。\n\n更通用的图像变换方法可以使用transform()\n\n**模式转换**\n\n\tconvert()方法\n\n**模式转换**\n\n\tim = Image.open('autojump.png').convert('L')\n\t\n**图像增强**\n\nFilter\nImageFilter模块包含很多预定义的增强filters，通过filter()方法使用\n\n应用filters\n\n\tfrom PIL import ImageFilter\n\tout = img.filter(ImageFilter.DETAIL) \n像素点处理\npoint()方法通过一个函数或者查询表对图像中的像素点进行处理（例如对比度操作）。\n\n**像素点变换**\n\n\t# multiply each pixel by 1.2\n\tout = img.point(lambda i: i * 1.2)\n上述方法可以利用简单的表达式进行图像处理，通过组合point()和paste()还能选择性地处理图片的某一区域。\n\n**处理单独通道**\n\n\t# split the image into individual bands\n\tsource = im.split()\n\n\tR, G, B = 0, 1, 2\n\n\t# select regions where red is less than 100\n\tmask = source[R].point(lambda i: i < 100 and 255)\n\n\t# process the green band\n\tout = source[G].point(lambda i: i * 0.7)\n\n\t# paste the processed band back, but only where red was < 100\n\tsource[G].paste(out, None, mask)\n\n\t# build a new multiband image\n\tim = Image.merge(im.mode, source)\n注意到创建mask的语句：\n\n\tmask = source[R].point(lambda i: i < 100 and 255)\n该句可以用下句表示\n\n\timout = im.point(lambda i: expression and 255)\n如果expression为假则返回expression的值为0（因为and语句已经可以得出结果了），否则返回255。（mask参数用法：当为0时，保留当前值，255为使用paste进来的值，中间则用于transparency效果）\n\n### 高级图片增强\n对其他高级图片增强，应该使用ImageEnhance模块 。一旦有一个Image对象，应用ImageEnhance对象就能快速地进行设置。 可以使用以下方法调整对比度、亮度、色平衡和锐利度。\n\n**图像增强**\n\n\tfrom PIL import ImageEnhance\n\t\n\tenh = ImageEnhance.Contrast(im)\n\tenh.enhance(1.3).show(\"30% more contrast\")\n**动态图**\n\nPillow支持一些动态图片的格式如FLI/FLC，GIF和其他一些处于实验阶段的格式。TIFF文件同样可以包含数帧图像。\n\n当读取动态图时，PIL自动读取动态图的第一帧，可以使用seek和tell方法读取不同帧。\n\n```\nfrom PIL import Image\n\nim = Image.open(\"animation.gif\")\nim.seek(1) # skip to the second frame\n\ntry:\n    while 1:\n        im.seek(im.tell()+1)\n        # do something to im\nexcept EOFError:\n    pass # end of sequence\n```\n\n**当读取到最后一帧时，Pillow抛出EOFError异常。**\n\n当前版本只允许seek到下一帧。为了倒回之前，必须重新打开文件。\n\n或者可以使用下述迭代器类\n\n**动态图迭代器类**\n\n```\nclass ImageSequence:\n    def __init__(self, im):\n        self.im = im\n    def __getitem__(self, ix):\n        try:\n            if ix:\n                self.im.seek(ix)\n            return self.im\n        except EOFError:\n            raise IndexError # end of sequence\n\nfor frame in ImageSequence(im):\n    # ...do something to frame...\nPostscript Printing\n```\n\nPillow允许通过Postscript Printer在图片上添加images、text、graphics。\n\n**Drawing Postscript**\n\n```\nfrom PIL import Image\nfrom PIL import PSDraw\n\nim = Image.open(\"lena.ppm\")\ntitle = \"lena\"\nbox = (1*72, 2*72, 7*72, 10*72) # in points\n\nps = PSDraw.PSDraw() # default is sys.stdout\nps.begin_document(title)\n\n# draw the image (75 dpi)\nps.image(box, im, 75)\nps.rectangle(box)\n\n# draw centered title\nps.setfont(\"HelveticaNarrow-Bold\", 36)\nw, h, b = ps.textsize(title)\nps.text((4*72-w/2, 1*72-h), title)\n\nps.end_document()\n```\n\n\n### 更多读取图片方法\n之前说到Image模块的open()函数已经足够日常使用。该函数的参数也可以是一个文件对象。\n\n从string中读取\n\n\timport StringIO\n\t\n\tim = Image.open(StringIO.StringIO(buffer))\n\t从tar文件中读取\n\t\n\tfrom PIL import TarIO\n\t\n\tfp = TarIO.TarIO(\"Imaging.tar\", \"Imaging/test/lena.ppm\")\n\tim = Image.open(fp)\n\t\n**草稿模式**\ndraft()方法允许在不读取文件内容的情况下尽可能（可能不会完全等于给定的参数）地将图片转成给定模式和大小，这在生成缩略图的时候非常有效（速度要求比质量高的场合）。\n\n**draft模式**\n\n```\nfrom __future__ import print_function\nim = Image.open(file)\nprint(\"original =\", im.mode, im.size)\n\nim.draft(\"L\", (100, 100))\nprint(\"draft =\", im.mode, im.size)\n```\n\n### 小实践：PIL处理图片之加水印\n\n```python\nfrom PIL import Image, ImageDraw, ImageFont\n\ndef add_num(img):\n\t#创建绘画对象\n    draw = ImageDraw.Draw(img)\n    #矢量字体支持 TrueType Font support\n    myfont = ImageFont.truetype('C:/windows/fonts/Arial.ttf', size=100)\n    #定义填充颜色\n    fillcolor = \"#f00\"\n    #获取图片大小\n    width, height = img.size\n    #在图片指定位置绘制文本内容然后保存\n    draw.text((width-660, 168), '1007', font=myfont, fill=fillcolor)\n    img.save('result.jpg','jpeg')\n\n    return 0\nif __name__ == '__main__':\n    image = Image.open('autojump1007.png')\n    add_num(image)\n```\n![这里写图片描述](http://img.blog.csdn.net/20180205222754605?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG9ja2V5MjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n**关于ImageDraw Module**\n基本绘画操作 Basic methods of drawing surface\n\n弧/弦/扇形 chord arc pieslice (bbox, strtAng, endAng)\n椭圆 ellipse (bbox)\n线段/多段线 line (L)  draw.line(((60,60),(90,60), (90,90), (60,90), (60,60))) #draw a square\n点 point (xy)  #单像素点很小看不清,实际中可用实心小圆代替\n多边形 polygon (L) draw.polygon([(60,60), (90,60), (90,90), (60,90)]) #draw a square\n矩形 rectangle (bbox)       # first coord属于矩形, second coord不属于\n文字 text(xy,message,font=None) 绘制文字message，文本区域左上角坐标为xy\n      drawable.text((10, 10), \"Hello\", fill=(255,0,0), font=None)\n文字大小 textsize(message,font=None)  给定文字message，返回所占像素(width,height)\n可选参数 Common optional args for these methods\n\nfill=fillColor\noutline=outlineColor\n",
		'date':' on Feb 5, 2018'
	},
	'prometheus-3-webui':{
		'title':'Webui of Prometheus',
		'content':"本文将结合配置和web界面对prometheus的基本使用做示例解说\n### 首先来看一下初始配置\n\n**prometheus.yml**\n```\n# my global config\nglobal:\n  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.\n  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.\n  # scrape_timeout is set to the global default (10s).\n\n# Alertmanager configuration\nalerting:\n  alertmanagers:\n  - static_configs:\n    - targets:\n       - localhost:9093\n\n# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.\nrule_files:\n   - \"/etc/prometheus/rules/*.yml\"\n  # - \"second_rules.yml\"\n\n# A scrape configuration containing exactly one endpoint to scrape:\n# Here it's Prometheus itself.\nscrape_configs:\n  # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.\n  - job_name: 'prometheus'\n\n    # metrics_path defaults to '/metrics'\n    # scheme defaults to 'http'.\n\n    static_configs:\n      - targets: ['localhost:9090']\n\n```\n\n\t在prometheus的基本配置中我们指定了Alertmanager为本地的Alertmanager；并且添加了一个服务，服务的端点只有一个，即prometheus自己；指定的报警规则读取路径为/etc/prometheus/rules/*.yml，稍后我们将会向这个路径中添加规则\n\t\n\n**alertmanager.yml**\n```\nglobal:\n  # The smarthost and SMTP sender used for mail notifications.\n  smtp_smarthost: 'localhost:25'\n  smtp_from: 'alertmanager@example.org'\n  smtp_auth_username: 'alertmanager'\n  smtp_auth_password: 'password'\n  # The auth token for Hipchat.\n\n# The directory from which notification templates are read.\ntemplates: \n- '/etc/alertmanager/template/*.tmpl'\n\n# The root route on which each incoming alert enters.\nroute:\n  # The labels by which incoming alerts are grouped together. For example,\n  # multiple alerts coming in for cluster=A and alertname=LatencyHigh would\n  # be batched into a single group.\n  group_by: ['alertname', 'cluster', 'service']\n\n  # When a new group of alerts is created by an incoming alert, wait at\n  # least 'group_wait' to send the initial notification.\n  # This way ensures that you get multiple alerts for the same group that start\n  # firing shortly after another are batched together on the first \n  # notification.\n  group_wait: 30s\n\n  # When the first notification was sent, wait 'group_interval' to send a batch\n  # of new alerts that started firing for that group.\n  group_interval: 5m\n\n  # If an alert has successfully been sent, wait 'repeat_interval' to\n  # resend them.\n  repeat_interval: 3h \n\n  # A default receiver\n  receiver: webhook\n\n  # All the above attributes are inherited by all child routes and can \n  # overwritten on each.\n\n  # The child route trees.\n  routes:\n\n# Inhibition rules allow to mute a set of alerts given that another alert is\n# firing.\n# We use this to mute any warning-level notifications if the same alert is \n# already critical.\ninhibit_rules:\n- source_match:\n    severity: 'critical'\n  target_match:\n    severity: 'warning'\n  # Apply inhibition if the alertname is the same.\n  equal: ['alertname', 'cluster', 'service']\n\n\nreceivers:\n- name: 'webhook'\n  webhook_configs:\n  - url: 'http://127.0.0.1:8090/alert_webhook'\n\n```\n\n\talertmanager的配置中我们只需要注意两处，即全局配置的接收者webhook以及路由部分指定的唯一接受者为webhook，等会我们将使用一个微服务来示例如何通过webhook接受报警信息\n\n### 接着我们结合内置的web界面修改配置来看一下效果\n\n\t在graph导航中我们输入查询语句然后选择需要展示的时间段就有了下面的展示结果\n![这里写图片描述](http://img.blog.csdn.net/20180121121614013?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG9ja2V5MjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\t然后我们在status->targets导航中查看当前的targets状态，因为基本配置中只有一个并且属于在线状态所以就会有一下展示：\n\t\n![这里写图片描述](http://img.blog.csdn.net/20180121121842889?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG9ja2V5MjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n然后我们虚构一个端点信息，在基本配置的targets列表中添加一项：\n![这里写图片描述](http://img.blog.csdn.net/20180121122200407?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG9ja2V5MjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n然后使服务重新加载配置：\n\t\n\tcurl -XPOST http://192.168.0.77:9090/-/reload\n\n刷新targets对应的界面可以看到如下展示（以下为隔了几秒刷新出现的两个状态展示）\n\n![这里写图片描述](http://img.blog.csdn.net/20180121122310298?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG9ja2V5MjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n![这里写图片描述](http://img.blog.csdn.net/20180121122319860?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG9ja2V5MjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\t因为端点'localhost:9100'当前不存在所以状态最终为'DOWN'\n\n### 接下来我们上一个规则看一下效果\n要配置规则就必须要对应一定的指标，想知道有哪些指标可以访问以下链接所指：\n![这里写图片描述](http://img.blog.csdn.net/20180121122913614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG9ja2V5MjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n首先我们先对条件做一个查询看一下图标信息：\n![这里写图片描述](http://img.blog.csdn.net/20180121123203845?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG9ja2V5MjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n然后我们来写规则，然后校验规则：\n\n```\n[root@vm7-1201-pure rules]# promtool check rules http_requests_total.yml \nChecking http_requests_total.yml\n  SUCCESS: 1 rules found\n\n[root@vm7-1201-pure rules]# cat http_requests_total.yml \ngroups:\n- name: http_requests_total\n  rules:\n  - alert: http_requests\n    expr: job:http_requests_total:mean5m{job=\"prometheus\"} > 900\n    for: 10m\n    labels:\n      severity: page\n    annotations:\n      summary: High request latency\n\n```\n\n因为当前没有重载使规则生效，所以界面上还是这样的\n![这里写图片描述](http://img.blog.csdn.net/20180121123836996?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG9ja2V5MjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n然后我们重新加载一下：\n\n\tcurl -XPOST http://127.0.0.1:9090/-/reload\n再来看一下界面：\n![这里写图片描述](http://img.blog.csdn.net/20180121124018307?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG9ja2V5MjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n当前的报警还未生效，然后我们一直刷新页面使http_requests_total的值上升到出发报警\n![这里写图片描述](http://img.blog.csdn.net/20180121125228021?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG9ja2V5MjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n这时候再去看alertmanager的状态，发现报警已经被接收到:\n![这里写图片描述](http://img.blog.csdn.net/20180121125407287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG9ja2V5MjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n",
		'date':' on Feb 1, 2018'
	},
	'prometheus-4-mysql':{
		'title':'Monitor MySQL via Prometheus',
		'content':"##监控MySQL服务器\n\n**平台为redhat 7.2 x86_64bit**\n\n为了使监控可视化，我们将借助于Grafana，基本安装【略】，对于要监控的对象MySQL还需要安装mysqld_exporter【略】，本文假设安装就绪。\n\n监控配置的基本架构如下：\n![这里写图片描述](http://img.blog.csdn.net/20180122224803261?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG9ja2V5MjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n### 配置mysqld_exporter\n\n**增加一个用于监控的MySQL用户**\n\n\tmysql> GRANT REPLICATION CLIENT, PROCESS ON *.* TO 'mysqld_exporter'@'localhost' identified by 'redhat';\n\tmysql> GRANT SELECT ON performance_schema.* TO 'mysqld_exporter'@'localhost';\n\tmysql> flush privileges;\n\n指定mysqld_exporter连接MySQL的配置文件，当然首先要写配置文件，位置随便，如我的：\n\n```\n[root@prometheus ~]# cat /etc/prometheus/.my.cnf \n[client]\nuser=mysqld_exporter\npassword=redhat\n\n``` \n\n然后在mysqld_exporter的启动程序中指定\n\n```\n[root@prometheus ~]# systemctl status mysqld_exporter\n● mysqld_exporter.service - Prometheus exporter for MySQL server metrics.\n   Loaded: loaded (/usr/lib/systemd/system/mysqld_exporter.service; disabled; vendor preset: disabled)\n   Active: active (running) since Mon 2018-01-22 22:00:20 CST; 1h 47min ago\n     Docs: https://github.com/prometheus/mysqld_exporter\n Main PID: 2680 (mysqld_exporter)\n   CGroup: /system.slice/mysqld_exporter.service\n           └─2680 /usr/bin/mysqld_exporter -config.my-cnf=/etc/prometheus/.my.cnf###注意这里，需要修改Systemd服务把这一项加上\n\n```\n\n完成以上配置之后重启或者启动mysqld_exporter\n\n### 配置prometheus,加入mysql监控目标\n\n```\n[root@prometheus ~]# tail -n 12 /etc/prometheus/prometheus.yml | head -n 6\n  - job_name: 'mysql'\n    static_configs:\n      - targets: ['localhost:9104']\n        labels:\n          instance: 'mysql1'\n\n```\n\n配置完成重启或者reload prometheus服务\n\n\tcurl -XPOST http://ip:9090/-/reload\n\n### 下载并且配置监控模板\n\n\tgit clone https://github.com/percona/grafana-dashboards.git\n\tcp -r grafana-dashboards/dashboards /var/lib/grafana/\n\n**编辑Grafana配置文件如下：**\n\n```\n[root@prometheus ~]# sed -n '370,373p' /etc/grafana/grafana.ini \n[dashboards.json]\nenabled = true\npath = /var/lib/grafana/dashboards\n```\n\n然后重新启动或者启动grafana-server，在浏览器中输入http://ip:3000进行访问（用户密码默认admin）\n![这里写图片描述](http://img.blog.csdn.net/20180122230421259?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG9ja2V5MjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n可以看到我们导入的模板\n![这里写图片描述](http://img.blog.csdn.net/20180122230611221?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG9ja2V5MjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**配置一下数据源为prometheus**\n点击最左上图标然后选中Data Sources-》add data datasource，然后按照以下内容填入\n![这里写图片描述](http://img.blog.csdn.net/20180122231054813?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG9ja2V5MjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n注意：\n\n\tType一定要是Prometheus\n\tURL是prometheus的端点url\n\tAccess选择proxy\n\t\n点击其中的MySQL Overview然后对查询条件做适当调整（点击每个图形的标题-》edit-》metrics）就会看到以下界面了：\n![这里写图片描述](http://img.blog.csdn.net/20180122230741570?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG9ja2V5MjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n",
		'date':' on Feb 1, 2018'
	}
}